import { Injectable } from '@angular/core';
import { EMPTY } from 'rxjs';
import { findPath } from './utils/find-path';
import * as i0 from "@angular/core";
import * as i1 from "./prefetch-registry.service";
import * as i2 from "@angular/router";
export class QuicklinkStrategy {
    constructor(registry, router) {
        this.registry = registry;
        this.router = router;
        this.loading = new Set();
    }
    preload(route, load) {
        if (this.loading.has(route)) {
            // Don't preload the same route twice
            return EMPTY;
        }
        const conn = typeof navigator !== 'undefined'
            ? navigator.connection
            : undefined;
        if (conn) {
            // Don't preload if the user is on 2G. or if Save-Data is enabled..
            if ((conn.effectiveType || '').includes('2g') || conn.saveData)
                return EMPTY;
        }
        // Prevent from preloading
        if (route.data && route.data['preload'] === false) {
            return EMPTY;
        }
        const fullPath = findPath(this.router.config, route);
        if (this.registry.shouldPrefetch(fullPath)) {
            this.loading.add(route);
            return load();
        }
        return EMPTY;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.2", ngImport: i0, type: QuicklinkStrategy, deps: [{ token: i1.PrefetchRegistry }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.2", ngImport: i0, type: QuicklinkStrategy, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.2", ngImport: i0, type: QuicklinkStrategy, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: i1.PrefetchRegistry }, { type: i2.Router }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVpY2tsaW5rLXN0cmF0ZWd5LnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcXVpY2tsaW5rL3NyYy9saWIvcXVpY2tsaW5rLXN0cmF0ZWd5LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUczQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQzs7OztBQUc3QyxNQUFNLE9BQU8saUJBQWlCO0lBRzVCLFlBQW9CLFFBQTBCLEVBQVUsTUFBYztRQUFsRCxhQUFRLEdBQVIsUUFBUSxDQUFrQjtRQUFVLFdBQU0sR0FBTixNQUFNLENBQVE7UUFGdEUsWUFBTyxHQUFHLElBQUksR0FBRyxFQUFTLENBQUM7SUFFOEMsQ0FBQztJQUUxRSxPQUFPLENBQUMsS0FBWSxFQUFFLElBQWM7UUFDbEMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUMzQixxQ0FBcUM7WUFDckMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE1BQU0sSUFBSSxHQUNSLE9BQU8sU0FBUyxLQUFLLFdBQVc7WUFDOUIsQ0FBQyxDQUFFLFNBQWlCLENBQUMsVUFBVTtZQUMvQixDQUFDLENBQUMsU0FBUyxDQUFDO1FBQ2hCLElBQUksSUFBSSxFQUFFO1lBQ1IsbUVBQW1FO1lBQ25FLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUTtnQkFDNUQsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCwwQkFBMEI7UUFDMUIsSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQ2pELE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDckQsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMxQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN4QixPQUFPLElBQUksRUFBRSxDQUFDO1NBQ2Y7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7OEdBOUJVLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBREosTUFBTTs7MkZBQ25CLGlCQUFpQjtrQkFEN0IsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQcmVsb2FkaW5nU3RyYXRlZ3ksIFJvdXRlciwgUm91dGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgUHJlZmV0Y2hSZWdpc3RyeSB9IGZyb20gJy4vcHJlZmV0Y2gtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgeyBFTVBUWSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmluZFBhdGggfSBmcm9tICcuL3V0aWxzL2ZpbmQtcGF0aCc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgUXVpY2tsaW5rU3RyYXRlZ3kgaW1wbGVtZW50cyBQcmVsb2FkaW5nU3RyYXRlZ3kge1xuICBsb2FkaW5nID0gbmV3IFNldDxSb3V0ZT4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZ2lzdHJ5OiBQcmVmZXRjaFJlZ2lzdHJ5LCBwcml2YXRlIHJvdXRlcjogUm91dGVyKSB7fVxuXG4gIHByZWxvYWQocm91dGU6IFJvdXRlLCBsb2FkOiBGdW5jdGlvbikge1xuICAgIGlmICh0aGlzLmxvYWRpbmcuaGFzKHJvdXRlKSkge1xuICAgICAgLy8gRG9uJ3QgcHJlbG9hZCB0aGUgc2FtZSByb3V0ZSB0d2ljZVxuICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH1cbiAgICBjb25zdCBjb25uID1cbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gKG5hdmlnYXRvciBhcyBhbnkpLmNvbm5lY3Rpb25cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGNvbm4pIHtcbiAgICAgIC8vIERvbid0IHByZWxvYWQgaWYgdGhlIHVzZXIgaXMgb24gMkcuIG9yIGlmIFNhdmUtRGF0YSBpcyBlbmFibGVkLi5cbiAgICAgIGlmICgoY29ubi5lZmZlY3RpdmVUeXBlIHx8ICcnKS5pbmNsdWRlcygnMmcnKSB8fCBjb25uLnNhdmVEYXRhKVxuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgfVxuICAgIC8vIFByZXZlbnQgZnJvbSBwcmVsb2FkaW5nXG4gICAgaWYgKHJvdXRlLmRhdGEgJiYgcm91dGUuZGF0YVsncHJlbG9hZCddID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH1cbiAgICBjb25zdCBmdWxsUGF0aCA9IGZpbmRQYXRoKHRoaXMucm91dGVyLmNvbmZpZywgcm91dGUpO1xuICAgIGlmICh0aGlzLnJlZ2lzdHJ5LnNob3VsZFByZWZldGNoKGZ1bGxQYXRoKSkge1xuICAgICAgdGhpcy5sb2FkaW5nLmFkZChyb3V0ZSk7XG4gICAgICByZXR1cm4gbG9hZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBFTVBUWTtcbiAgfVxufVxuIl19